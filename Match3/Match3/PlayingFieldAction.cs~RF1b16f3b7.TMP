using Microsoft.VisualBasic;
using Microsoft.Xna.Framework;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Match3
{
    public class PlayingFieldAction
    {
        private static int gemsLeft = 50;
        private static bool gemCanMove;
        List<Point> rowThatCanMove = new();

        public static void DeclearDestination()
        {
            bool gemHasDestination = true;

            for (int x = 0; x < Data.tileMap.GetLength(0); x++)
            {
                for (int y = Data.tileMap.GetLength(1) - 1; y >= 0; y--)
                {
                    if (Data.tileMap[x, y].gem != null && !Data.tileMap[x, y].isFilled)
                    {
                        if (Data.tileMap[x, y].gem.destination == null)
                        {
                            gemHasDestination = false;
                            break;
                        }
                    }
                }

                if (!gemHasDestination)
                {
                    Point? des = null;
                    bool hasFound = false;

                    for (int y = Data.tileMap.GetLength(1) - 1; y >= 0; y--)
                    {
                        if (!Data.tileMap[x, y].isFilled && Data.tileMap[x, y].canHaveGem)
                        {
                            if (des == null && !hasFound)
                            {
                                des = Data.tileMap[x, y].position;
                                Data.tileMap[x, y].isFilled = true;
                            }
                        }

                        if (!Data.tileMap[x, y].isFilled && Data.tileMap[x, y].gem != null && des != null)
                        {
                            if (Data.tileMap[x, y].gem.destination == null)
                            {
                                Data.tileMap[x, y].gem.destination = des;
                                hasFound = true;
                                des = null;
                            }
                        }

                        if (hasFound)
                        {
                            y = Data.tileMap.GetLength(1) - 1;
                            hasFound = false;
                        }
                        //else if (!hasFound && y == 0)
                        //{
                        //    break;
                        //}
                    }
                }
            }
        }

        public static void CheckIfGemCanMove()
        {
            for (int i = Data.gameObjects.Count - 1; i >= 0; i--)
            {
                if (Data.gameObjects[i] is Gem g)
                {
                    if (g.position.Y >= g.destination.Value.ToVector2().Y * Data.tileSize)
                    {
                        g.Direction(Direction.none);
                        Gem temp = new Gem(g.destination.Value.ToVector2() * Data.tileSize, g.gemType);
                        Data.tileMap[g.destination.Value.X, g.destination.Value.Y].gem = temp;
                        Data.gameObjects.RemoveAt(i);
                        //ClearMatches();
                    }
                }
            }

            MoveGemsDown();
        }

        public static void MoveGemsDown()
        {
            CanGemMove();

            if (gemCanMove)
            {
                DeclearDestination();

                for (int x = 0; x < Data.tileMap.GetLength(0); x++)
                {
                    for (int y = Data.tileMap.GetLength(1) - 1; y >= 0; y--)
                    {
                        if (Data.tileMap[x, y].gem != null && !Data.tileMap[x, y].isFilled)
                        {
                            if (Data.tileMap[x, y].gem.destination != null)
                            {
                                Gem tempGem = Data.tileMap[x, y].gem;
                                tempGem.Direction(Direction.down);

                                Data.gameObjects.Add(tempGem);
                                Data.tileMap[x, y].gem = null;
                            }
                        }
                    }
                }
            }
        }

        private static void CanGemMove()
        {
            List<Point> rowThatCanMove = new();

            for (int x = 0; x < Data.tileMap.GetLength(0); x++)
            {
                for (int y = Data.tileMap.GetLength(1) - 1; y >= 0; y--)
                {
                    if (Data.tileMap[x, y].canHaveGem && Data.tileMap[x, y].gem == null)
                    {
                        gemCanMove = true;
                        rowThatCanMove.Add(new Point(x, y));
                        break;
                    }
                }
            }

            for (int x = 0; x < Data.tileMap.GetLength(0); x++)
            {
                for (int y = Data.tileMap.GetLength(1) - 1; y >= 0; y--)
                {
                    for (int i = 0; i < rowThatCanMove.Count; i++)
                    {
                        if (Data.tileMap[x, y].gem != null)
                        {
                            if (Data.tileMap[x, y].position.Y < rowThatCanMove[i].Y && Data.tileMap[x, y].position.X == rowThatCanMove[i].X)
                            {
                                Data.tileMap[x, y].isFilled = false;
                            }
                        }
                    }
                }
            }

            if (rowThatCanMove.Count == 0)
            {
                gemCanMove = false;
            }
        }

        public static void SpawnNewGems()
        {
            // Spawn gems at rows where there was a clear
        }

        public static void ClearMatches()
        {
            List<Point[]> verticalMatches = CheckVertical(), horizontalMatches = CheckHorizontal();

            foreach (Point[] points in horizontalMatches)
            {
                foreach (Point point in points)
                {
                    Data.tileMap[point.X, point.Y].gem = null;
                    Data.tileMap[point.X, point.Y].isFilled = false;
                }
            }
            foreach (Point[] points in verticalMatches)
            {
                foreach (Point point in points)
                {
                    Data.tileMap[point.X, point.Y].gem = null;
                    Data.tileMap[point.X, point.Y].isFilled = false;
                }
            }
        }

        public static List<Point[]> CheckVertical()
        {
            Gem currentGem = null;
            List<Point[]> totalMatches = new();
            List<Point> tempMatches = new();

            for (int x = 0; x < Data.tileMap.GetLength(0); x++)
            {
                if (tempMatches.Count >= 3)
                {
                    totalMatches.Add(tempMatches.ToArray());
                }

                tempMatches.Clear();

                for (int y = 0; y < Data.tileMap.GetLength(0); y++)
                {
                    if (currentGem != null && Data.tileMap[x, y].gem != null && currentGem.texutre == Data.tileMap[x, y].gem.texutre && currentGem.position.X == Data.tileMap[x, y].gem.position.X && Data.tileMap[x, y].isFilled)
                    {
                        tempMatches.Add(new Point(x, y));
                    }
                    else if (tempMatches.Count >= 3)
                    {
                        totalMatches.Add(tempMatches.ToArray());
                        tempMatches.Clear();
                    }
                    else
                    {
                        tempMatches.Clear();
                        if (Data.tileMap[x, y].gem != null && Data.tileMap[x, y].isFilled)
                        {
                            currentGem = Data.tileMap[x, y].gem;
                        }
                        else if (!Data.tileMap[x, y].canHaveGem)
                        {
                            currentGem = null;
                        }
                        tempMatches.Add(new Point(x, y));
                    }
                }
            }

            return totalMatches;
        }

        public static List<Point[]> CheckHorizontal()
        {
            Gem currentGem = null;
            List<Point[]> totalMatches = new();
            List<Point> tempMatches = new();

            for (int y = 0; y < Data.tileMap.GetLength(0); y++)
            {
                if (tempMatches.Count >= 3)
                {
                    totalMatches.Add(tempMatches.ToArray());
                }

                tempMatches.Clear();

                for (int x = 0; x < Data.tileMap.GetLength(0); x++)
                {
                    if (currentGem != null && Data.tileMap[x, y].gem != null && currentGem.texutre == Data.tileMap[x, y].gem.texutre && currentGem.position.Y == Data.tileMap[x, y].gem.position.Y && Data.tileMap[x, y].isFilled)
                    {
                        tempMatches.Add(new Point(x, y));
                    }
                    else if (tempMatches.Count >= 3)
                    {
                        totalMatches.Add(tempMatches.ToArray());
                        tempMatches.Clear();
                    }
                    else
                    {
                        tempMatches.Clear();
                        if (Data.tileMap[x, y].gem != null && Data.tileMap[x, y].isFilled)
                        {
                            currentGem = Data.tileMap[x, y].gem;
                        }
                        else if (!Data.tileMap[x, y].canHaveGem)
                        {
                            currentGem = null;
                        }
                        tempMatches.Add(new Point(x, y));
                    }
                }
            }

            return totalMatches;
        }
    }
}
